package crypto;

import java.security.KeyPair;
import java.security.PublicKey;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.crypto.KeyAgreement;

import com.google.protobuf.ByteString;

import crypto.CryptoGrpc.CryptoBlockingStub;
import crypto.CryptoOuterClass.CipherSuite;
import crypto.CryptoOuterClass.HandshakeData;
import crypto.CryptoOuterClass.OpenConnectionRequest;
import crypto.CryptoOuterClass.OpenConnectionResponse;
import io.grpc.Channel;
import io.grpc.Grpc;
import io.grpc.InsecureChannelCredentials;
import io.grpc.ManagedChannel;

public class CryptoClient {
  private static final Logger logger = Logger.getLogger(CryptoClient.class
      .getName());

  private final CryptoBlockingStub blockingStub;

  public CryptoClient(Channel channel) {
    blockingStub = CryptoGrpc.newBlockingStub(channel);
  }

  public void doHandshake(CipherSuite cipherSuite) {
    DH algoInst = null;
    KeyPair clientKeyPair = null;
    switch (cipherSuite) {
      case DH:
        algoInst = DH.getInstance();
        clientKeyPair = algoInst.generateKeyPair(2048);
        break;
      case ECDH:
        algoInst = ECDH.getInstance();
        clientKeyPair = ECDH.getInstance().generateKeyPair("secp256r1");
        break;
      default:
        logger.log(Level.SEVERE, "Invalid handshake algorithm");
    }
    if (algoInst == null || clientKeyPair == null) {
      return;
    }
    KeyAgreement clientKeyAgreement = algoInst.getKeyAgreement(
        clientKeyPair);
    if (clientKeyAgreement == null) {
      return;
    }

    byte[] clientPublicKeyBuf = clientKeyPair.getPublic().getEncoded();
    logger.log(Level.INFO, "Client's public key: " + Util.toHexString(
          clientPublicKeyBuf));

    OpenConnectionRequest request = OpenConnectionRequest.newBuilder()
        .addHandshakeDataList(HandshakeData.newBuilder()
            .setCipherSuite(cipherSuite)
            .setData(ByteString.copyFrom(clientPublicKeyBuf))
            .build())
        .build();
    OpenConnectionResponse response = blockingStub.openConnection(request);
    HandshakeData serverHandshakeData = response.getHandshakeData();
    CipherSuite serverCipherSuite = serverHandshakeData.getCipherSuite();
    // TODO: verify serverCipherSuite
    byte[] serverData = serverHandshakeData.getData().toByteArray();
    PublicKey serverPublicKey = algoInst.getPeerPublicKey(serverData);
    if (serverPublicKey == null) {
      return;
    }
    boolean nextPhaseOk = algoInst.doPhase(clientKeyAgreement,
        serverPublicKey);
    if (!nextPhaseOk) {
      return;
    }

    byte[] sharedSecret = clientKeyAgreement.generateSecret();
    logger.log(Level.INFO, "Shared secret generated by client: " +
        Util.toHexString(sharedSecret, ":"));
  }

  public static void main(String[] args) throws InterruptedException {
    ManagedChannel channel = Grpc.newChannelBuilder("localhost:50051",
        InsecureChannelCredentials.create()).build();
    try {
      CryptoClient client = new CryptoClient(channel);
      client.doHandshake(CipherSuite.DH);
      client.doHandshake(CipherSuite.ECDH);
    } finally {
      channel.shutdownNow().awaitTermination(5, TimeUnit.SECONDS);
    }
  }
}
