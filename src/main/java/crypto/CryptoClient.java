package crypto;

import java.security.KeyPair;
import java.security.PublicKey;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.crypto.KeyAgreement;

import com.google.protobuf.ByteString;

import crypto.CryptoGrpc.CryptoBlockingStub;
import crypto.CryptoOuterClass.CipherSuite;
import crypto.CryptoOuterClass.HandshakeData;
import crypto.CryptoOuterClass.OpenConnectionRequest;
import crypto.CryptoOuterClass.OpenConnectionResponse;
import io.grpc.Channel;
import io.grpc.Grpc;
import io.grpc.InsecureChannelCredentials;
import io.grpc.ManagedChannel;

public class CryptoClient {
  private static final Logger logger = Logger.getLogger(CryptoClient.class
      .getName());

  private final CryptoBlockingStub blockingStub;

  public CryptoClient(Channel channel) {
    blockingStub = CryptoGrpc.newBlockingStub(channel);
  }

  public void doHandshake() {
    KeyPair clientKeyPair = DH.dhGenerateKeyPair(DH.KEY_SIZE.DH_KEY_SIZE_2048);
    if (clientKeyPair == null) {
      return;
    }
    KeyAgreement clientKeyAgreement = DH.dhGetKeyAgreement(clientKeyPair);
    if (clientKeyAgreement == null) {
      return;
    }

    byte[] clientPublicKeyBuf = clientKeyPair.getPublic().getEncoded();
    logger.log(Level.INFO, "Client's public key: " + Util.toHexString(
          clientPublicKeyBuf));

    OpenConnectionRequest request = OpenConnectionRequest.newBuilder()
        .addHandshakeDataList(HandshakeData.newBuilder()
            .setCipherSuite(CipherSuite.DH)
            .setData(ByteString.copyFrom(clientPublicKeyBuf))
            .build())
        .build();
    OpenConnectionResponse response = blockingStub.openConnection(request);
    HandshakeData serverHandshakeData = response.getHandshakeData();
    CipherSuite serverCipherSuite = serverHandshakeData.getCipherSuite();
    // TODO: verify serverCipherSuite
    byte[] serverData = serverHandshakeData.getData().toByteArray();
    PublicKey serverPublicKey = DH.getPeerPublicKey(serverData);
    if (serverPublicKey == null) {
      return;
    }
    boolean nextPhaseOk = DH.dhDoPhase(clientKeyAgreement, serverPublicKey);
    if (!nextPhaseOk) {
      return;
    }

    byte[] sharedSecret = clientKeyAgreement.generateSecret();
    logger.log(Level.INFO, "Shared secret generated by server: " +
        Util.toHexString(sharedSecret, ":"));
  }

  public static void main(String[] args) throws InterruptedException {
    ManagedChannel channel = Grpc.newChannelBuilder("localhost:50051",
        InsecureChannelCredentials.create()).build();
    try {
      CryptoClient client = new CryptoClient(channel);
      client.doHandshake();
    } finally {
      channel.shutdownNow().awaitTermination(5, TimeUnit.SECONDS);
    }
  }
}
