package crypto;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assumptions.assumeFalse;

import crypto.CryptoOuterClass.CipherSuite;
import java.security.KeyPair;
import java.security.PublicKey;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.crypto.KeyAgreement;
import org.junit.jupiter.api.Test;

public class DhEcdhTest {
  private static final Logger logger = Logger.getLogger(DhEcdhTest.class.getName());

  void dh_ecdh_client_server(CipherSuite cipherSuite, boolean benchmark) {
    // Algorithm choosing and client generates its' key pair
    DH algoInst = null;
    KeyPair clientKeyPair = null;
    switch (cipherSuite) {
      case DH:
        algoInst = DH.getInstance();
        clientKeyPair = algoInst.generateKeyPair(2048);
        break;
      case ECDH:
        algoInst = ECDH.getInstance();
        clientKeyPair = ECDH.getInstance().generateKeyPair("secp256r1");
        break;
      default:
        assumeFalse(true);
    }
    if (clientKeyPair == null) {
      assertFalse(!benchmark);
    }
    // Client creates key agreement based on the generated key pair
    KeyAgreement clientKeyAgreement = algoInst.getKeyAgreement(clientKeyPair);
    if (clientKeyAgreement == null) {
      assertFalse(!benchmark);
    }
    // Client sends its' public key to server
    byte[] clientPublicKeyBuf = clientKeyPair.getPublic().getEncoded();
    if (!benchmark) {
      logger.log(Level.INFO, "Client's public key: " + Util.toHexString(clientPublicKeyBuf));
    }

    // ---

    // Server receives client's public key
    PublicKey clientPublicKey = algoInst.getPeerPublicKey(clientPublicKeyBuf);
    if (clientPublicKey == null) {
      assertFalse(!benchmark);
    }
    // Server generates its' public key base on client's public key
    KeyPair serverKeyPair = algoInst.generateKeyPair(clientPublicKey);
    if (serverKeyPair == null) {
      assertFalse(!benchmark);
    }
    // Server sends its' public key to client
    byte[] serverPublicKeyBuf = serverKeyPair.getPublic().getEncoded();
    if (!benchmark) {
      logger.log(Level.INFO, "Server's public key: " + Util.toHexString(serverPublicKeyBuf));
    }
    // Server creates key agreement based on the generated key pair
    KeyAgreement keyAgreement = algoInst.getKeyAgreement(serverKeyPair);
    if (keyAgreement == null) {
      assertFalse(!benchmark);
    }
    // Server verify client public key before generating shared secret
    boolean doPhaseOk = algoInst.doPhase(keyAgreement, clientPublicKey);
    if (!doPhaseOk) {
      assertFalse(!benchmark);
    }
    // Server generates shared secret
    byte[] serverSharedSecret = keyAgreement.generateSecret();
    if (!benchmark) {
      logger.log(
          Level.INFO,
          "Shared secret generated by server: " + Util.toHexString(serverSharedSecret, ":"));
    }

    // ---

    // Client receives server's public key
    PublicKey serverPublicKey = algoInst.getPeerPublicKey(serverPublicKeyBuf);
    if (serverPublicKey == null) {
      assertFalse(!benchmark);
    }
    // Client verify server public key before generating shared secret
    boolean nextPhaseOk = algoInst.doPhase(clientKeyAgreement, serverPublicKey);
    if (!nextPhaseOk) {
      assertFalse(!benchmark);
    }
    // Client generates shared secret
    byte[] clientSharedSecret = clientKeyAgreement.generateSecret();
    if (!benchmark) {
      logger.log(
          Level.INFO,
          "Shared secret generated by client: " + Util.toHexString(clientSharedSecret, ":"));
    }

    // ---

    if (!benchmark) {
      assertArrayEquals(clientSharedSecret, serverSharedSecret);
    }
  }

  @Test
  void dh() {
    dh_ecdh_client_server(CipherSuite.DH, false);
  }

  @Test
  void ecdh() {
    dh_ecdh_client_server(CipherSuite.ECDH, false);
  }
}
